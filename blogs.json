{"status":"ok","feed":{"url":"https://medium.com/feed/@iamgagantyagi","title":"Stories by Gagan Tyagi on Medium","link":"https://medium.com/@iamgagantyagi?source=rss-8892f5387155------2","author":"","description":"Stories by Gagan Tyagi on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*C49sotTgRwoWmcbW54xpwg.jpeg"},"items":[{"title":"Deploying Multiple NGINX Ingress Controllers in an OCI Virtual Node Cluster","pubDate":"2024-04-18 09:18:47","link":"https://iamgagantyagi.medium.com/deploying-multiple-nginx-ingress-controllers-in-an-oci-virtual-node-cluster-d7807ad55c85?source=rss-8892f5387155------2","guid":"https://medium.com/p/d7807ad55c85","author":"Gagan Tyagi","thumbnail":"","description":"\n<blockquote>Managing ingress traffic in a Kubernetes cluster can be a complex task, especially when you have both internal and external applications that need to be accessible. In this blog post, we\u2019ll explore how to set up multiple NGINX Ingress Controllers in an Oracle Cloud Infrastructure (OCI) Virtual Node cluster, one for an external load balancer and one for an internal load balancer in the same\u00a0cluster.</blockquote>\n<p><strong>Objectives</strong></p>\n<p>By the end of this blog post, you will have learned how\u00a0to:</p>\n<ol>\n<li>Deploy a NGINX Ingress Controller for the external load balancer.</li>\n<li>Deploy a NGINX Ingress Controller for the internal load balancer.</li>\n<li>Configure the Ingress Controllers to use different Ingress\u00a0classes.</li>\n<li>Create sample Ingress objects for both external and internal applications deployments.</li>\n</ol>\n<p><strong>Prerequisites</strong></p>\n<ol>\n<li>An OCI account with the necessary permissions to create Virtual Nodes, load balancers, and Kubernetes resources.</li>\n<li>Kubectl and Helm (version 3) installed on your local\u00a0machine.</li>\n<li>Access to the OCI Cloud Shell or a machine with the OCI CLI installed.</li>\n</ol>\n<p><strong>Flow Chart\u00a0Diagram</strong></p>\n<figure><img alt=\"High level overview of nginx ingress inside OKE-V cluster\" src=\"https://cdn-images-1.medium.com/max/971/1*b-1LT3q3qYfVMU3dGFER2Q.png\"></figure><p><strong>Implementation Steps</strong></p>\n<p><strong>Create an OCI Virtual Node\u00a0Cluster:</strong></p>\n<p>The first step is to create an OCI Virtual Node cluster. You can use the GitHub repository provided in the documentation to install and configure the OKE Virtual Node cluster in your environment:</p>\n<blockquote><a href=\"https://github.com/oracle-devrel/terraform-oci-arch-oke-virtual-node\">https://github.com/oracle-devrel/terraform-oci-arch-oke-virtual-node</a></blockquote>\n<p><strong>Configure the Kubernetes Context</strong></p>\n<p>Once you have the cluster set up, you need to configure the Kubernetes context. Open the OCI Cloud Shell or your local machine with the OCI CLI installed and run the following command:</p>\n<blockquote>oci ce cluster get-credentials\u200a\u2014\u200acluster-id &lt;cluster-ocid&gt;\u200a\u2014\u200afile ~/.kube/config\u200a\u2014\u200aregion\u00a0&lt;region&gt;</blockquote>\n<p>Note: Replace &lt;cluster-ocid&gt; with the OCID of your Virtual Node cluster and &lt;region&gt; with the region where your cluster is\u00a0located.</p>\n<p><strong>Deploy the External NGINX Ingress Controller</strong></p>\n<p>Now, let\u2019s deploy the external NGINX Ingress Controller This will create an external (public) load balancer:</p>\n<p>1. Add the NGINX Ingress Controller Helm repository:</p>\n<blockquote>helm repo add ingress-nginx <a href=\"https://kubernetes.github.io/ingress-nginx\">https://kubernetes.github.io/ingress-nginx</a>\n</blockquote>\n<p>2. Install the external NGINX Ingress Controller:</p>\n<pre>helm install external ingress-nginx/ingress-nginx \\<br>- namespace external - create-namespace - wait \\<br> - set controller.replicaCount=2 \\<br> - set rbac.create=true \\<br> - set controller.ingressClass=external \\<br> - set controller.ingressClassResource.default=false \\<br> - set controller.ingressClass=external-nginx \\<br> - set controller.ingressClassResource.name=external-nginx \\<br> - set controller.ingressClassResource.controllerValue=\"k8s.io/external-nginx\" \\<br> - set controller.service.type=LoadBalancer \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape\"=flexible \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-max\"=100 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-min\"=10 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-internal\"=false</pre>\n<p><strong>Deploy the Internal NGINX Ingress Controller</strong></p>\n<p>Next, let\u2019s deploy the internal NGINX Ingress Controller. This will create an internal (private) load balancer:</p>\n<p>1. Install the internal NGINX Ingress Controller:</p>\n<pre>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx<br>helm repo update<br>helm install internal ingress-nginx/ingress-nginx \\<br> - namespace internal - create-namespace - wait \\<br> - set rbac.create=true \\<br> - set controller.ingressClass=internal \\<br> - set controller.ingressClassResource.default=true \\<br> - set controller.ingressClass=internal-nginx \\<br> - set controller.ingressClassResource.name=internal-nginx \\<br> - set controller.ingressClassResource.controllerValue=\"k8s.io/internal-nginx\" \\<br> - set controller.service.type=LoadBalancer \\<br> - set controller.replicaCount=2 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape\"=flexible \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-max\"=100 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-min\"=10 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-internal\"=true \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-subnet1\"=ocid1.subnet.oc1.iad.aaaaa\u2026\u2026\u2026\u2026..</pre>\n<p>1. Check the status of the Ingress Controllers:</p>\n<blockquote>kubectl get pods -n internal #\u2190\u200a\u2014\u200aInternal ingress controller pods</blockquote>\n<blockquote>kubectl get pods -n external #\u2190\u200a\u2014\u200aExternal ingress controller pods</blockquote>\n<p>You should see two Ingress Controller pods, one for the external and one for the internal load balancer.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*jZk5UyDIl__w3KGSyxRY3Q.png\"></figure><p>2. Retrieve the external and internal load balancer IP addresses:</p>\n<blockquote>kubectl get svc \u2013n\u00a0internal</blockquote>\n<blockquote>kubectl get svc \u2013n\u00a0external</blockquote>\n<p>Note the external and internal IP addresses for the Ingress LoadBalancers.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/810/1*PqO5YvQ4dvss2YA7Esddnw.png\"></figure><p><strong>Verify both external/internal IngressClass\u00a0:</strong></p>\n<p>You should see two ingressclasses one for internal &amp; one for\u00a0external</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/757/1*D_zjNnOiq0SkuJGU3z3zLg.png\"></figure><p><strong>Create deployments with Ingress objects for external &amp;\u00a0internal</strong></p>\n<ol><li>Create a deployment with external Ingress\u00a0object:</li></ol>\n<pre>apiVersion: apps/v1  <br><br>kind: Deployment  <br><br>metadata:  <br><br>  name: hello-world-ext  <br><br>  labels:  <br><br>    app: hello-world-ext  <br><br>spec:  <br><br>  selector:  <br><br>    matchLabels:  <br><br>      app: hello-world-ext  <br><br>  replicas: 1  <br><br>  template:  <br><br>    metadata:  <br><br>      labels:  <br><br>        app: hello-world-ext  <br><br>    spec:  <br><br>      containers:  <br><br>      - name: hello-world-ext  <br><br>        image: testcontainers/helloworld  <br><br>        ports:  <br><br>        - containerPort: 8080  <br><br>---  <br><br>apiVersion: v1  <br><br>kind: Service  <br><br>metadata:  <br><br>  name: hello-world-ext-svc  <br><br>spec:  <br><br>  selector:  <br><br>    app: hello-world-ext  <br><br>  ports:  <br><br>    - protocol: TCP  <br><br>      port: 8000  <br><br>      targetPort: 8080  <br><br>  type: ClusterIP  <br><br>---  <br><br>apiVersion: networking.k8s.io/v1  <br><br>kind: Ingress  <br><br>metadata:  <br><br>  name: hello-world-ext-ingress  <br><br>  annotations:  <br><br>    nginx.ingress.kubernetes.io/rewrite-target: /$1  <br><br>spec:  <br><br>  ingressClassName: \"external-nginx\"  #&lt;--- external-nginx ingressclass  <br><br>  rules:  <br><br>  - host: hello-world.info  <br><br>    http:  <br><br>      paths:  <br><br>        - path: /v1  <br><br>          pathType: Prefix  <br><br>          backend:  <br><br>            service:  <br><br>              name: hello-world-ext-svc  <br><br>              port:  <br><br>                number: 8000 </pre>\n<p>2. Apply the deployment for External\u00a0Ingress:</p>\n<blockquote>kubectl apply -f hello-world-ext.yaml</blockquote>\n<p>3. Create a deployment with Internal Ingress\u00a0object:</p>\n<pre>apiVersion: apps/v1  <br><br>kind: Deployment  <br><br>metadata:  <br><br>  name: hello-world-int  <br><br>  labels:  <br><br>    app: hello-world-int  <br><br>spec:  <br><br>  selector:  <br><br>    matchLabels:  <br><br>      app: hello-world-int  <br><br>  replicas: 1  <br><br>  template:  <br><br>    metadata:  <br><br>      labels:  <br><br>        app: hello-world-int  <br><br>    spec:  <br><br>      containers:  <br><br>      - name: hello-world-int  <br><br>        image: testcontainers/helloworld  <br><br>        ports:  <br><br>        - containerPort: 8080  <br><br>---  <br><br>apiVersion: v1  <br><br>kind: Service  <br><br>metadata:  <br><br>  name: hello-world-int-svc  <br><br>spec:  <br><br>  selector:  <br><br>    app: hello-world-int  <br><br>  ports:  <br><br>    - protocol: TCP  <br><br>      port: 8000  <br><br>      targetPort: 8080  <br><br>  type: ClusterIP  <br><br><br><br>---  <br><br>apiVersion: networking.k8s.io/v1  <br><br>kind: Ingress  <br><br>metadata:  <br><br>  name: hello-world-int-ingress  <br><br>  annotations:  <br><br>    nginx.ingress.kubernetes.io/rewrite-target: /$1  <br><br>spec:  <br><br>  ingressClassName: \"internal-nginx\" #&lt;--- internal-nginx ingressclass <br><br>  rules:  <br><br>  - host: hello-world.info  <br><br>    http:  <br><br>      paths:  <br><br>        - path: /v1  <br><br>          pathType: Prefix  <br><br>          backend:  <br><br>            service:  <br><br>              name: hello-world-int-svc  <br><br>              port:  <br><br>                number: 8000 </pre>\n<p>4. Apply the deployment for Internal\u00a0Ingress:</p>\n<blockquote>kubectl apply -f hello-world-int.yaml</blockquote>\n<p><strong>Test the Ingress Controllers</strong></p>\n<p>1. Access the external application using the external load balancer IP\u00a0address.</p>\n<pre>curl \u2013H 'Host: hello-world.info' http://129.213.10.68/v1</pre>\n<p>2. Access the internal application using the internal load balancer IP\u00a0address.</p>\n<pre>curl \u2013H 'Host: hello-world.info' http://10.0.30.135/v1</pre>\n<p><strong>Conclusion</strong></p>\n<p>In this blog post, we have successfully deployed two NGINX Ingress Controllers in an OCI Virtual Node cluster, one for the external load balancer and one for the internal load balancer. We have also created sample Ingress resources for both external and internal applications, utilizing the different Ingress\u00a0classes.</p>\n<p>This setup allows us to manage ingress traffic for both internal and external applications running in the same Kubernetes cluster, providing a flexible and scalable solution for your application deployment.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d7807ad55c85\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<blockquote>Managing ingress traffic in a Kubernetes cluster can be a complex task, especially when you have both internal and external applications that need to be accessible. In this blog post, we\u2019ll explore how to set up multiple NGINX Ingress Controllers in an Oracle Cloud Infrastructure (OCI) Virtual Node cluster, one for an external load balancer and one for an internal load balancer in the same\u00a0cluster.</blockquote>\n<p><strong>Objectives</strong></p>\n<p>By the end of this blog post, you will have learned how\u00a0to:</p>\n<ol>\n<li>Deploy a NGINX Ingress Controller for the external load balancer.</li>\n<li>Deploy a NGINX Ingress Controller for the internal load balancer.</li>\n<li>Configure the Ingress Controllers to use different Ingress\u00a0classes.</li>\n<li>Create sample Ingress objects for both external and internal applications deployments.</li>\n</ol>\n<p><strong>Prerequisites</strong></p>\n<ol>\n<li>An OCI account with the necessary permissions to create Virtual Nodes, load balancers, and Kubernetes resources.</li>\n<li>Kubectl and Helm (version 3) installed on your local\u00a0machine.</li>\n<li>Access to the OCI Cloud Shell or a machine with the OCI CLI installed.</li>\n</ol>\n<p><strong>Flow Chart\u00a0Diagram</strong></p>\n<figure><img alt=\"High level overview of nginx ingress inside OKE-V cluster\" src=\"https://cdn-images-1.medium.com/max/971/1*b-1LT3q3qYfVMU3dGFER2Q.png\"></figure><p><strong>Implementation Steps</strong></p>\n<p><strong>Create an OCI Virtual Node\u00a0Cluster:</strong></p>\n<p>The first step is to create an OCI Virtual Node cluster. You can use the GitHub repository provided in the documentation to install and configure the OKE Virtual Node cluster in your environment:</p>\n<blockquote><a href=\"https://github.com/oracle-devrel/terraform-oci-arch-oke-virtual-node\">https://github.com/oracle-devrel/terraform-oci-arch-oke-virtual-node</a></blockquote>\n<p><strong>Configure the Kubernetes Context</strong></p>\n<p>Once you have the cluster set up, you need to configure the Kubernetes context. Open the OCI Cloud Shell or your local machine with the OCI CLI installed and run the following command:</p>\n<blockquote>oci ce cluster get-credentials\u200a\u2014\u200acluster-id &lt;cluster-ocid&gt;\u200a\u2014\u200afile ~/.kube/config\u200a\u2014\u200aregion\u00a0&lt;region&gt;</blockquote>\n<p>Note: Replace &lt;cluster-ocid&gt; with the OCID of your Virtual Node cluster and &lt;region&gt; with the region where your cluster is\u00a0located.</p>\n<p><strong>Deploy the External NGINX Ingress Controller</strong></p>\n<p>Now, let\u2019s deploy the external NGINX Ingress Controller This will create an external (public) load balancer:</p>\n<p>1. Add the NGINX Ingress Controller Helm repository:</p>\n<blockquote>helm repo add ingress-nginx <a href=\"https://kubernetes.github.io/ingress-nginx\">https://kubernetes.github.io/ingress-nginx</a>\n</blockquote>\n<p>2. Install the external NGINX Ingress Controller:</p>\n<pre>helm install external ingress-nginx/ingress-nginx \\<br>- namespace external - create-namespace - wait \\<br> - set controller.replicaCount=2 \\<br> - set rbac.create=true \\<br> - set controller.ingressClass=external \\<br> - set controller.ingressClassResource.default=false \\<br> - set controller.ingressClass=external-nginx \\<br> - set controller.ingressClassResource.name=external-nginx \\<br> - set controller.ingressClassResource.controllerValue=\"k8s.io/external-nginx\" \\<br> - set controller.service.type=LoadBalancer \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape\"=flexible \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-max\"=100 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-min\"=10 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-internal\"=false</pre>\n<p><strong>Deploy the Internal NGINX Ingress Controller</strong></p>\n<p>Next, let\u2019s deploy the internal NGINX Ingress Controller. This will create an internal (private) load balancer:</p>\n<p>1. Install the internal NGINX Ingress Controller:</p>\n<pre>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx<br>helm repo update<br>helm install internal ingress-nginx/ingress-nginx \\<br> - namespace internal - create-namespace - wait \\<br> - set rbac.create=true \\<br> - set controller.ingressClass=internal \\<br> - set controller.ingressClassResource.default=true \\<br> - set controller.ingressClass=internal-nginx \\<br> - set controller.ingressClassResource.name=internal-nginx \\<br> - set controller.ingressClassResource.controllerValue=\"k8s.io/internal-nginx\" \\<br> - set controller.service.type=LoadBalancer \\<br> - set controller.replicaCount=2 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape\"=flexible \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-max\"=100 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-min\"=10 \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-internal\"=true \\<br> - set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/oci-load-balancer-subnet1\"=ocid1.subnet.oc1.iad.aaaaa\u2026\u2026\u2026\u2026..</pre>\n<p>1. Check the status of the Ingress Controllers:</p>\n<blockquote>kubectl get pods -n internal #\u2190\u200a\u2014\u200aInternal ingress controller pods</blockquote>\n<blockquote>kubectl get pods -n external #\u2190\u200a\u2014\u200aExternal ingress controller pods</blockquote>\n<p>You should see two Ingress Controller pods, one for the external and one for the internal load balancer.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*jZk5UyDIl__w3KGSyxRY3Q.png\"></figure><p>2. Retrieve the external and internal load balancer IP addresses:</p>\n<blockquote>kubectl get svc \u2013n\u00a0internal</blockquote>\n<blockquote>kubectl get svc \u2013n\u00a0external</blockquote>\n<p>Note the external and internal IP addresses for the Ingress LoadBalancers.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/810/1*PqO5YvQ4dvss2YA7Esddnw.png\"></figure><p><strong>Verify both external/internal IngressClass\u00a0:</strong></p>\n<p>You should see two ingressclasses one for internal &amp; one for\u00a0external</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/757/1*D_zjNnOiq0SkuJGU3z3zLg.png\"></figure><p><strong>Create deployments with Ingress objects for external &amp;\u00a0internal</strong></p>\n<ol><li>Create a deployment with external Ingress\u00a0object:</li></ol>\n<pre>apiVersion: apps/v1  <br><br>kind: Deployment  <br><br>metadata:  <br><br>  name: hello-world-ext  <br><br>  labels:  <br><br>    app: hello-world-ext  <br><br>spec:  <br><br>  selector:  <br><br>    matchLabels:  <br><br>      app: hello-world-ext  <br><br>  replicas: 1  <br><br>  template:  <br><br>    metadata:  <br><br>      labels:  <br><br>        app: hello-world-ext  <br><br>    spec:  <br><br>      containers:  <br><br>      - name: hello-world-ext  <br><br>        image: testcontainers/helloworld  <br><br>        ports:  <br><br>        - containerPort: 8080  <br><br>---  <br><br>apiVersion: v1  <br><br>kind: Service  <br><br>metadata:  <br><br>  name: hello-world-ext-svc  <br><br>spec:  <br><br>  selector:  <br><br>    app: hello-world-ext  <br><br>  ports:  <br><br>    - protocol: TCP  <br><br>      port: 8000  <br><br>      targetPort: 8080  <br><br>  type: ClusterIP  <br><br>---  <br><br>apiVersion: networking.k8s.io/v1  <br><br>kind: Ingress  <br><br>metadata:  <br><br>  name: hello-world-ext-ingress  <br><br>  annotations:  <br><br>    nginx.ingress.kubernetes.io/rewrite-target: /$1  <br><br>spec:  <br><br>  ingressClassName: \"external-nginx\"  #&lt;--- external-nginx ingressclass  <br><br>  rules:  <br><br>  - host: hello-world.info  <br><br>    http:  <br><br>      paths:  <br><br>        - path: /v1  <br><br>          pathType: Prefix  <br><br>          backend:  <br><br>            service:  <br><br>              name: hello-world-ext-svc  <br><br>              port:  <br><br>                number: 8000 </pre>\n<p>2. Apply the deployment for External\u00a0Ingress:</p>\n<blockquote>kubectl apply -f hello-world-ext.yaml</blockquote>\n<p>3. Create a deployment with Internal Ingress\u00a0object:</p>\n<pre>apiVersion: apps/v1  <br><br>kind: Deployment  <br><br>metadata:  <br><br>  name: hello-world-int  <br><br>  labels:  <br><br>    app: hello-world-int  <br><br>spec:  <br><br>  selector:  <br><br>    matchLabels:  <br><br>      app: hello-world-int  <br><br>  replicas: 1  <br><br>  template:  <br><br>    metadata:  <br><br>      labels:  <br><br>        app: hello-world-int  <br><br>    spec:  <br><br>      containers:  <br><br>      - name: hello-world-int  <br><br>        image: testcontainers/helloworld  <br><br>        ports:  <br><br>        - containerPort: 8080  <br><br>---  <br><br>apiVersion: v1  <br><br>kind: Service  <br><br>metadata:  <br><br>  name: hello-world-int-svc  <br><br>spec:  <br><br>  selector:  <br><br>    app: hello-world-int  <br><br>  ports:  <br><br>    - protocol: TCP  <br><br>      port: 8000  <br><br>      targetPort: 8080  <br><br>  type: ClusterIP  <br><br><br><br>---  <br><br>apiVersion: networking.k8s.io/v1  <br><br>kind: Ingress  <br><br>metadata:  <br><br>  name: hello-world-int-ingress  <br><br>  annotations:  <br><br>    nginx.ingress.kubernetes.io/rewrite-target: /$1  <br><br>spec:  <br><br>  ingressClassName: \"internal-nginx\" #&lt;--- internal-nginx ingressclass <br><br>  rules:  <br><br>  - host: hello-world.info  <br><br>    http:  <br><br>      paths:  <br><br>        - path: /v1  <br><br>          pathType: Prefix  <br><br>          backend:  <br><br>            service:  <br><br>              name: hello-world-int-svc  <br><br>              port:  <br><br>                number: 8000 </pre>\n<p>4. Apply the deployment for Internal\u00a0Ingress:</p>\n<blockquote>kubectl apply -f hello-world-int.yaml</blockquote>\n<p><strong>Test the Ingress Controllers</strong></p>\n<p>1. Access the external application using the external load balancer IP\u00a0address.</p>\n<pre>curl \u2013H 'Host: hello-world.info' http://129.213.10.68/v1</pre>\n<p>2. Access the internal application using the internal load balancer IP\u00a0address.</p>\n<pre>curl \u2013H 'Host: hello-world.info' http://10.0.30.135/v1</pre>\n<p><strong>Conclusion</strong></p>\n<p>In this blog post, we have successfully deployed two NGINX Ingress Controllers in an OCI Virtual Node cluster, one for the external load balancer and one for the internal load balancer. We have also created sample Ingress resources for both external and internal applications, utilizing the different Ingress\u00a0classes.</p>\n<p>This setup allows us to manage ingress traffic for both internal and external applications running in the same Kubernetes cluster, providing a flexible and scalable solution for your application deployment.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d7807ad55c85\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["kubernetes","oracle","terraform","api","devops"]}]}