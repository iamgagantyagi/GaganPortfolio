{
  "version": "https://jsonfeed.org/version/1",
  "title": "Stories by Gagan Tyagi on Medium",
  "home_page_url": "https://medium.com/@iamgagantyagi?source=rss-8892f5387155------2",
  "description": "Stories by Gagan Tyagi on Medium",
  "author": {
    "name": "yourfriends@medium.com"
  },
  "items": [
    {
      "guid": "https://medium.com/p/d7807ad55c85",
      "url": "https://iamgagantyagi.medium.com/deploying-multiple-nginx-ingress-controllers-in-an-oci-virtual-node-cluster-d7807ad55c85?source=rss-8892f5387155------2",
      "title": "Deploying Multiple NGINX Ingress Controllers in an OCI Virtual Node Cluster",
      "content_html": "<blockquote>Managing ingress traffic in a Kubernetes cluster can be a complex task, especially when you have both internal and external applications that need to be accessible. In this blog post, we’ll explore how to set up multiple NGINX Ingress Controllers in an Oracle Cloud Infrastructure (OCI) Virtual Node cluster, one for an external load balancer and one for an internal load balancer in the same cluster.</blockquote><p><strong>Objectives</strong></p><p>By the end of this blog post, you will have learned how to:</p><ol><li>Deploy a NGINX Ingress Controller for the external load balancer.</li><li>Deploy a NGINX Ingress Controller for the internal load balancer.</li><li>Configure the Ingress Controllers to use different Ingress classes.</li><li>Create sample Ingress objects for both external and internal applications deployments.</li></ol><p><strong>Prerequisites</strong></p><ol><li>An OCI account with the necessary permissions to create Virtual Nodes, load balancers, and Kubernetes resources.</li><li>Kubectl and Helm (version 3) installed on your local machine.</li><li>Access to the OCI Cloud Shell or a machine with the OCI CLI installed.</li></ol><p><strong>Flow Chart Diagram</strong></p><figure><img alt=\"High level overview of nginx ingress inside OKE-V cluster\" src=\"https://cdn-images-1.medium.com/max/971/1*b-1LT3q3qYfVMU3dGFER2Q.png\" /></figure><p><strong>Implementation Steps</strong></p><p><strong>Create an OCI Virtual Node Cluster:</strong></p><p>The first step is to create an OCI Virtual Node cluster. You can use the GitHub repository provided in the documentation to install and configure the OKE Virtual Node cluster in your environment:</p><blockquote><a href=\"https://github.com/oracle-devrel/terraform-oci-arch-oke-virtual-node\">https://github.com/oracle-devrel/terraform-oci-arch-oke-virtual-node</a></blockquote><p><strong>Configure the Kubernetes Context</strong></p><p>Once you have the cluster set up, you need to configure the Kubernetes context. Open the OCI Cloud Shell or your local machine with the OCI CLI installed and run the following command:</p><blockquote>oci ce cluster get-credentials — cluster-id &lt;cluster-ocid&gt; — file ~/.kube/config — region &lt;region&gt;</blockquote><p>Note: Replace &lt;cluster-ocid&gt; with the OCID of your Virtual Node cluster and &lt;region&gt; with the region where your cluster is located.</p><p><strong>Deploy the External NGINX Ingress Controller</strong></p><p>Now, let’s deploy the external NGINX Ingress Controller This will create an external (public) load balancer:</p><p>1. Add the NGINX Ingress Controller Helm repository:</p><blockquote>helm repo add ingress-nginx <a href=\"https://kubernetes.github.io/ingress-nginx\">https://kubernetes.github.io/ingress-nginx</a></blockquote><p>2. Install the external NGINX Ingress Controller:</p><pre>helm install external ingress-nginx/ingress-nginx \\<br>- namespace external - create-namespace - wait \\<br> - set controller.replicaCount=2 \\<br> - set rbac.create=true \\<br> - set controller.ingressClass=external \\<br> - set controller.ingressClassResource.default=false \\<br> - set controller.ingressClass=external-nginx \\<br> - set controller.ingressClassResource.name=external-nginx \\<br> - set controller.ingressClassResource.controllerValue=&quot;k8s.io/external-nginx&quot; \\<br> - set controller.service.type=LoadBalancer \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape&quot;=flexible \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-max&quot;=100 \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-min&quot;=10 \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-internal&quot;=false</pre><p><strong>Deploy the Internal NGINX Ingress Controller</strong></p><p>Next, let’s deploy the internal NGINX Ingress Controller. This will create an internal (private) load balancer:</p><p>1. Install the internal NGINX Ingress Controller:</p><pre>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx<br>helm repo update<br>helm install internal ingress-nginx/ingress-nginx \\<br> - namespace internal - create-namespace - wait \\<br> - set rbac.create=true \\<br> - set controller.ingressClass=internal \\<br> - set controller.ingressClassResource.default=true \\<br> - set controller.ingressClass=internal-nginx \\<br> - set controller.ingressClassResource.name=internal-nginx \\<br> - set controller.ingressClassResource.controllerValue=&quot;k8s.io/internal-nginx&quot; \\<br> - set controller.service.type=LoadBalancer \\<br> - set controller.replicaCount=2 \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape&quot;=flexible \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-max&quot;=100 \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-shape-flex-min&quot;=10 \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-internal&quot;=true \\<br> - set controller.service.annotations.&quot;service\\.beta\\.kubernetes\\.io/oci-load-balancer-subnet1&quot;=ocid1.subnet.oc1.iad.aaaaa…………..</pre><p>1. Check the status of the Ingress Controllers:</p><blockquote>kubectl get pods -n internal #← — Internal ingress controller pods</blockquote><blockquote>kubectl get pods -n external #← — External ingress controller pods</blockquote><p>You should see two Ingress Controller pods, one for the external and one for the internal load balancer.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*jZk5UyDIl__w3KGSyxRY3Q.png\" /></figure><p>2. Retrieve the external and internal load balancer IP addresses:</p><blockquote>kubectl get svc –n internal</blockquote><blockquote>kubectl get svc –n external</blockquote><p>Note the external and internal IP addresses for the Ingress LoadBalancers.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/810/1*PqO5YvQ4dvss2YA7Esddnw.png\" /></figure><p><strong>Verify both external/internal IngressClass :</strong></p><p>You should see two ingressclasses one for internal &amp; one for external</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/757/1*D_zjNnOiq0SkuJGU3z3zLg.png\" /></figure><p><strong>Create deployments with Ingress objects for external &amp; internal</strong></p><ol><li>Create a deployment with external Ingress object:</li></ol><pre>apiVersion: apps/v1  <br><br>kind: Deployment  <br><br>metadata:  <br><br>  name: hello-world-ext  <br><br>  labels:  <br><br>    app: hello-world-ext  <br><br>spec:  <br><br>  selector:  <br><br>    matchLabels:  <br><br>      app: hello-world-ext  <br><br>  replicas: 1  <br><br>  template:  <br><br>    metadata:  <br><br>      labels:  <br><br>        app: hello-world-ext  <br><br>    spec:  <br><br>      containers:  <br><br>      - name: hello-world-ext  <br><br>        image: testcontainers/helloworld  <br><br>        ports:  <br><br>        - containerPort: 8080  <br><br>---  <br><br>apiVersion: v1  <br><br>kind: Service  <br><br>metadata:  <br><br>  name: hello-world-ext-svc  <br><br>spec:  <br><br>  selector:  <br><br>    app: hello-world-ext  <br><br>  ports:  <br><br>    - protocol: TCP  <br><br>      port: 8000  <br><br>      targetPort: 8080  <br><br>  type: ClusterIP  <br><br>---  <br><br>apiVersion: networking.k8s.io/v1  <br><br>kind: Ingress  <br><br>metadata:  <br><br>  name: hello-world-ext-ingress  <br><br>  annotations:  <br><br>    nginx.ingress.kubernetes.io/rewrite-target: /$1  <br><br>spec:  <br><br>  ingressClassName: &quot;external-nginx&quot;  #&lt;--- external-nginx ingressclass  <br><br>  rules:  <br><br>  - host: hello-world.info  <br><br>    http:  <br><br>      paths:  <br><br>        - path: /v1  <br><br>          pathType: Prefix  <br><br>          backend:  <br><br>            service:  <br><br>              name: hello-world-ext-svc  <br><br>              port:  <br><br>                number: 8000 </pre><p>2. Apply the deployment for External Ingress:</p><blockquote>kubectl apply -f hello-world-ext.yaml</blockquote><p>3. Create a deployment with Internal Ingress object:</p><pre>apiVersion: apps/v1  <br><br>kind: Deployment  <br><br>metadata:  <br><br>  name: hello-world-int  <br><br>  labels:  <br><br>    app: hello-world-int  <br><br>spec:  <br><br>  selector:  <br><br>    matchLabels:  <br><br>      app: hello-world-int  <br><br>  replicas: 1  <br><br>  template:  <br><br>    metadata:  <br><br>      labels:  <br><br>        app: hello-world-int  <br><br>    spec:  <br><br>      containers:  <br><br>      - name: hello-world-int  <br><br>        image: testcontainers/helloworld  <br><br>        ports:  <br><br>        - containerPort: 8080  <br><br>---  <br><br>apiVersion: v1  <br><br>kind: Service  <br><br>metadata:  <br><br>  name: hello-world-int-svc  <br><br>spec:  <br><br>  selector:  <br><br>    app: hello-world-int  <br><br>  ports:  <br><br>    - protocol: TCP  <br><br>      port: 8000  <br><br>      targetPort: 8080  <br><br>  type: ClusterIP  <br><br> <br><br>---  <br><br>apiVersion: networking.k8s.io/v1  <br><br>kind: Ingress  <br><br>metadata:  <br><br>  name: hello-world-int-ingress  <br><br>  annotations:  <br><br>    nginx.ingress.kubernetes.io/rewrite-target: /$1  <br><br>spec:  <br><br>  ingressClassName: &quot;internal-nginx&quot; #&lt;--- internal-nginx ingressclass <br><br>  rules:  <br><br>  - host: hello-world.info  <br><br>    http:  <br><br>      paths:  <br><br>        - path: /v1  <br><br>          pathType: Prefix  <br><br>          backend:  <br><br>            service:  <br><br>              name: hello-world-int-svc  <br><br>              port:  <br><br>                number: 8000 </pre><p>4. Apply the deployment for Internal Ingress:</p><blockquote>kubectl apply -f hello-world-int.yaml</blockquote><p><strong>Test the Ingress Controllers</strong></p><p>1. Access the external application using the external load balancer IP address.</p><pre>curl –H &#39;Host: hello-world.info&#39; http://129.213.10.68/v1</pre><p>2. Access the internal application using the internal load balancer IP address.</p><pre>curl –H &#39;Host: hello-world.info&#39; http://10.0.30.135/v1</pre><p><strong>Conclusion</strong></p><p>In this blog post, we have successfully deployed two NGINX Ingress Controllers in an OCI Virtual Node cluster, one for the external load balancer and one for the internal load balancer. We have also created sample Ingress resources for both external and internal applications, utilizing the different Ingress classes.</p><p>This setup allows us to manage ingress traffic for both internal and external applications running in the same Kubernetes cluster, providing a flexible and scalable solution for your application deployment.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d7807ad55c85\" width=\"1\" height=\"1\" alt=\"\">",
      "date_published": "2024-04-18T09:18:47.000Z",
      "author": {
        "name": "Gagan Tyagi"
      }
    }
  ]
}